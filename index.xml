<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Const Volatile</title>
    <link>https://cmbrandenburg.github.io/</link>
    <description>Recent content on Const Volatile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://cmbrandenburg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Announcing Chill v0.1.1</title>
      <link>https://cmbrandenburg.github.io/post/2016-04-18-chill_v0.1.1/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cmbrandenburg.github.io/post/2016-04-18-chill_v0.1.1/</guid>
      <description>&lt;p&gt;Chill v0.1.1 is &lt;a href=&#34;https://crates.io/crates/chill&#34;&gt;now available&lt;/a&gt;. Chill is a client-side
CouchDB library for the Rust programming language.&lt;/p&gt;

&lt;p&gt;This release adds support for executing views, meaning an application
using Chill can now use CouchDB for interesting work&amp;mdash;and not
merely as a document store.&lt;/p&gt;

&lt;p&gt;This release also adds support for manipulating attachments&amp;mdash;though
only indirectly, as a consequence of actions that read or update
documents. For example, an application can:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Read a document from the CouchDB server,&lt;/li&gt;
&lt;li&gt;Insert an attachment to the application&amp;rsquo;s in-memory representation of
the document, and,&lt;/li&gt;
&lt;li&gt;Update the document by sending the updated representation to the
CouchDB server.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Consequently, the CouchDB server will contain the new attachment.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the full &lt;a href=&#34;https://github.com/chill-rs/chill/blob/v0.1.1/CHANGELOG.md&#34;&gt;change_log&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My aim for future releases is to stick to a three-week release train,
with each release containing whichever changes happen to make it in to
the master branch during that time. I believe this schedule will work
well until Chill provides broad coverage of the CouchDB API.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rethinking CouchDB in Rust</title>
      <link>https://cmbrandenburg.github.io/post/2016-02-23-rethinking_couchdb_in_rust/</link>
      <pubDate>Tue, 23 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cmbrandenburg.github.io/post/2016-02-23-rethinking_couchdb_in_rust/</guid>
      <description>&lt;p&gt;My knowledge of Rust has surpassed my knowledge of CouchDB. I now think
less about &lt;em&gt;how&lt;/em&gt; to abstract the CouchDB API and more about &lt;em&gt;what&lt;/em&gt; to
abstract. Additionally, I believe my original strategy for the &lt;a href=&#34;https://github.com/couchdb-rs/couchdb&#34;&gt;couchdb
crate&lt;/a&gt; is a bad idea.&lt;/p&gt;

&lt;p&gt;That strategy is to provide a thin abstraction whereby the application
has fine-grained control over each HTTP request it sends to the CouchDB
server. Here&amp;rsquo;s an example request with one query parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// GET /stuff/my_doc?rev=&amp;lt;some_revision&amp;gt;
client.get_document(&amp;quot;/stuff/my_doc&amp;quot;)
      .rev(&amp;amp;some_revision)
      .run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s not much abstraction here. The application explicitly sets the
URI path and &lt;code&gt;rev&lt;/code&gt; query parameter. This level of abstraction leads to
two problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The CouchDB API provides many ways of doing the same thing, so the
library would also provide many ways of doing the same thing—i.e.,
bloat.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The library is less useful to most applications.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s look at the first problem: &lt;strong&gt;bloat&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Here are some examples how CouchDB has two ways of doing the same thing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Are you creating a document? You can PUT the document &lt;em&gt;or&lt;/em&gt; POST it to
the database.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Are you deleting a document? You can specify its revision via the
&lt;code&gt;If-Match&lt;/code&gt; header &lt;em&gt;or&lt;/em&gt; the &lt;code&gt;rev&lt;/code&gt; query parameter.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Are you uploading an attachment? You can embed the attachment content
as JSON using base64-encoding &lt;em&gt;or&lt;/em&gt; use a multipart message to separate
the attachment from its document and avoid the overhead of base64.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A good CouchDB library will hide meaningless choices and use a
reasonable default. For example, the library should use multipart to
upload attachment content because multipart uses significantly less
bandwidth than base64 in real-world cases. Application programmers
shouldn&amp;rsquo;t be bothered about this detail.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s even more to be said about attachments, and that brings us to
the second point: &lt;strong&gt;being useful&lt;/strong&gt;. But before I explain this, you need
a basic, two-minute understanding of CouchDB attachments.&lt;/p&gt;

&lt;p&gt;A CouchDB attachment is a MIME-typed blob added to a document—think
&lt;q&gt;email attachment.&lt;/q&gt; But, unlike an email, a CouchDB document is
revision-controlled, hence each attachment has a history. Imagine the
following sequence of events:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You create a document with an attachment containing the content
&lt;q&gt;Hello&lt;/q&gt; at document revision 1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You update the attachment with the content &lt;q&gt;Goodbye&lt;/q&gt; at document
revision 2.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After updating the attachment, you can retrieve the original
&lt;q&gt;Hello&lt;/q&gt; content by explicitly requesting revision 1.&lt;/p&gt;

&lt;p&gt;But what happens to an attachment when you update the document itself?
That depends on how much info you send in your update:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If you send the full attachment, including content, then the server
will overwrite the existing attachment with the new content.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or, if you send an attachment &lt;q&gt;stub&lt;/q&gt; containing only the
attachment&amp;rsquo;s name, then the server will make no changes to the
existing attachment.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or, if you send no attachment info at all, the server will delete the
existing attachment.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If the library requires the application to explicitly provide attachment
info—as the couchdb crate does—then deletion is the default. But
deletion is a bad default. A better default would be to send a stub and
make no changes.&lt;/p&gt;

&lt;p&gt;However, a CouchDB library that does automatic stub-sending would take
more control over the outgoing HTTP request. Such a library would also
need to know about all attachments without the application telling the
library about them. Is this even possible? Yes.&lt;/p&gt;

&lt;p&gt;Imagine the following pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Meta {
    id: DocumentId,
    revision: Revision,
    attachments: HashMap&amp;lt;String, Attachment&amp;gt;,
}

struct Speech {
    transcript: String,
}

let doc1 = db.read_document(&amp;quot;gettysburg&amp;quot;);

let (meta, mut content): (Meta, Speech) = doc1.into_content();

if content.transcript == &amp;quot;Four score and *eight* years ago…&amp;quot; {

    // Oops! Need to correct Lincoln&#39;s speech.
    content.transcript = &amp;quot;Four score and *seven* years ago…&amp;quot;.to_owned();

    let doc2 = Document::from_content(meta, content);
    db.write_document(doc2); // sends a stub for any existing attachment
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A key fact is that the CouchDB server sends attachment info as part of
any document. Hence, in the code above, the &lt;code&gt;doc1&lt;/code&gt; variable holds
all attachment info, and it transfers the info to &lt;code&gt;meta&lt;/code&gt;, with &lt;code&gt;meta&lt;/code&gt;
later transferring the info to &lt;code&gt;doc2&lt;/code&gt;. When the application sends &lt;code&gt;doc2&lt;/code&gt;
to the server, the library knows enough to send a stub for any existing
attachment.&lt;/p&gt;

&lt;p&gt;Suppose instead the application adds (or modifies) an attachment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let doc3 = db.read_document(&amp;quot;washington_farewell&amp;quot;);

let (mut meta, content): (Meta, Speech) = doc3.into_content();
meta.attachments.insert(&amp;quot;manuscript.png&amp;quot;,
                        Attachment::new(&amp;quot;image/png&amp;quot;, load_image()));
let doc4 = Document::from_content(meta, content);

db.write_document(doc4); // sends a stub for any preexisting attachment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the &lt;code&gt;doc4&lt;/code&gt; variable has enough info to send the full
content of the new &lt;code&gt;manuscript.png&lt;/code&gt; attachment and a stub for any other,
preexisting attachment. Waste not, want not.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been exploring this and other ideas in my new project,
&lt;a href=&#34;https://github.com/cmbrandenburg/chill-rs&#34;&gt;Chill&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Chill hides more HTTP headers, URI query parameters, and JSON content of
the HTTP messages. With Chill, the application declares &lt;em&gt;what&lt;/em&gt; to do and
Chill figures out &lt;em&gt;how&lt;/em&gt; to do it.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;My thanks go to Jeremy Wright for editing early drafts of this article
and making it better.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hibernating in Debian using a temporary swap file</title>
      <link>https://cmbrandenburg.github.io/post/2015-12-24-hibernating_in_debian_using_a_temporary_swap_file/</link>
      <pubDate>Thu, 24 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://cmbrandenburg.github.io/post/2015-12-24-hibernating_in_debian_using_a_temporary_swap_file/</guid>
      <description>

&lt;p&gt;This article explains how to configure a Debian Jessie system to
hibernate using swap space that&amp;rsquo;s created just before suspending and
destroyed just after resuming. This trick allows hibernation on a
swap-free or swap-lite system—useful on a desktop system running with
enough RAM to make swap space otherwise unnecessary.&lt;/p&gt;

&lt;h2 id=&#34;how-to-make-it-work:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;How to make it work&lt;/h2&gt;

&lt;h3 id=&#34;determine-the-root-partition-of-your-system:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Determine the root partition of your system&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ rootdev=$(mount | grep &#39; / &#39; | awk &#39;{ print $1 }&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Important!&lt;/em&gt; Make sure you get this right. Otherwise your system may
fail to suspend or—much worse—fail to resume.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo $rootdev
/dev/sda1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second line (e.g., &lt;code&gt;/dev/sda1&lt;/code&gt;) should be your system&amp;rsquo;s root
partition.&lt;/p&gt;

&lt;h3 id=&#34;install-and-configure-uswsusp:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Install and configure &lt;code&gt;uswsusp&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install uswsusp &amp;amp;&amp;amp;
  sudo sh -c &amp;quot;cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/uswsusp.conf
resume device = $rootdev
compress = y
early writeout = y
shutdown method = platform
image size = 0
resume offset = 0
EOF&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hibernating using a swap file—as opposed to a swap partition—requires
special support. We&amp;rsquo;ll use &lt;code&gt;uswsusp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;/etc/uswsusp.conf&lt;/code&gt; is the configuration file for &lt;code&gt;uswsusp&lt;/code&gt;. The
&lt;code&gt;image size&lt;/code&gt; and &lt;code&gt;resume offset&lt;/code&gt; lines are placeholders that we&amp;rsquo;ll
overwrite each time before suspending.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note.&lt;/em&gt; It&amp;rsquo;s also possible to hibernate to a swap file using &lt;code&gt;systemd&lt;/code&gt;,
but my only experience doing this is with Arch Linux, and, as far as I
know, the swap file must exist upon boot-up, thus preventing the swap
file from being created on demand.&lt;/p&gt;

&lt;h3 id=&#34;update-grub-to-add-the-resume-kernel-parameter:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Update Grub to add the &lt;code&gt;resume&lt;/code&gt; kernel parameter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ { grep -q &#39;\&amp;lt;GRUB_CMDLINE_LINUX_DEFAULT=.*resume=&#39; /etc/default/grub &amp;amp;&amp;amp;
      (echo &#39;Warning: The `resume` parameter is already set.&#39; &amp;gt;&amp;amp;2 || true) } ||
    { sudo sed --in-place \
        -e &amp;quot;s#^\\(GRUB_CMDLINE_LINUX_DEFAULT=\&amp;quot;\\)#\\1resume=$rootdev #&amp;quot; \
        /etc/default/grub &amp;amp;&amp;amp;
      sudo update-grub; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;resume&lt;/code&gt; kernel is necessary to resume from a swap file.
Otherwise the kernel will not find the swap file, and the system will
boot normally—as though rebooting.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;resume&lt;/code&gt; parameter is already set, you&amp;rsquo;ll need to take
intelligent action to resolve.&lt;/p&gt;

&lt;h3 id=&#34;install-the-dynamic-hibernate-script:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Install the &lt;code&gt;dynamic-hibernate&lt;/code&gt; script&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo wget -O /usr/local/sbin/dynamic-hibernate \
    https://raw.githubusercontent.com/cmbrandenburg/pcconf/e7dbe6128a9267b1f55fed27b22fcbfdc1734b3e/bin/dynamic-hibernate &amp;amp;&amp;amp;
  sudo chmod +x /usr/local/sbin/dynamic-hibernate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;dynamic-hibernate&lt;/code&gt; script does the actual hibernation. It:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sets up a temporary swap file,&lt;/li&gt;
&lt;li&gt;Updates the &lt;code&gt;/etc/uswsusp.conf&lt;/code&gt; with the location of the new swap
file,&lt;/li&gt;
&lt;li&gt;Re-creates the system&amp;rsquo;s initial RAM disk,&lt;/li&gt;
&lt;li&gt;Suspends the system, and&lt;/li&gt;
&lt;li&gt;Deletes the swap file after resuming.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By default, the script requests the kernel to store the smallest image
possible when suspending, presumably by discarding disk buffers and
disk-backed pages that may be safely reloaded after resuming. In my
experience, smaller images yield faster resume speeds when using a
spinning disk, and SSDs are fast enough to make any difference
negligible. Nevertheless, if you want to change this behavior then
modify the &lt;code&gt;image size&lt;/code&gt; value in the script.&lt;/p&gt;

&lt;h3 id=&#34;give-yourself-sudo-permission-to-hibernate-optional:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Give yourself &lt;code&gt;sudo&lt;/code&gt; permission to hibernate (optional)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sed --in-place \
  -e &amp;quot;\$a$USER ALL = NOPASSWD: /usr/local/sbin/dynamic-hibernate&amp;quot; \
  /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives permission to your current user account to run the
&lt;code&gt;dynamic-hibernate&lt;/code&gt; script without entering a password.&lt;/p&gt;

&lt;h3 id=&#34;create-a-script-to-lock-the-screen-and-hibernate-optional:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Create a script to lock the screen and hibernate (optional)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir -p ~/bin &amp;amp;&amp;amp;
  touch ~/bin/hibernate &amp;amp;&amp;amp;
  chmod +x ~/bin/hibernate &amp;amp;&amp;amp;
  cat &amp;lt;&amp;lt;EOF &amp;gt;~/bin/hibernate
#!/bin/sh
gnome-screensaver-command --lock
sudo /usr/local/sbin/dynamic-hibernate
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Locking the screen requires the user to enter a password after resuming.
Without locking the screen, anyone who resumes your computer during
hibernation will gain access to your system.&lt;/p&gt;

&lt;p&gt;The above script works only if you&amp;rsquo;re using the Gnome screensaver. If
you&amp;rsquo;re using a different screensaver then you must change the
&lt;code&gt;~/bin/hibernate&lt;/code&gt; script appropriately.&lt;/p&gt;

&lt;h3 id=&#34;verify-everything-works:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Verify everything works&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ ~/bin/hibernate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/local/sbin/dynamic-hibernate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your system will take a few moments to save state before powering off.
Power the system back on, and the system should restore its state as it
was before suspending.&lt;/p&gt;

&lt;h2 id=&#34;additional-considerations:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;Additional considerations&lt;/h2&gt;

&lt;p&gt;Once you get hibernation working, it should continue to work reliably.
However, here are some further considerations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t hibernate after upgrading the kernel. Reboot first. Otherwise
the kernel you resume with will be a different kernel than what you
suspended with, and the mismatch will cause mayhem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your system fails to suspend then there&amp;rsquo;s a good chance the
hibernation script will print a useful error message.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your system fails to suspend or resume then you may need to
manually delete the swap file that gets left behind
(&lt;code&gt;/swap.hibernate&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If your system fails to resume then your system will suffer the same
consequences as though it crashed. This includes loss of application
state, file corruption, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;references:b629a1729d7f2b6331bf76a5082b2687&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cmbrandenburg/pcconf#hibernation&#34;&gt;https://github.com/cmbrandenburg/pcconf#hibernation&lt;/a&gt;. These are the
notes I use to set up a desktop system.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>